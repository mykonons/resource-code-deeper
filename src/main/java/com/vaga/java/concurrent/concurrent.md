# 多线程
## [写一个线程安全的单例](singleton)
### volatile的作用
防止指令重排序。volatile在修饰变量后，编译后会多出lock前缀指令。
作用是强制线程对变量的操作立即写入到物理内存。强制其他CPU读时从物理内存获取值。
## 实现多线程的几种方式
1. 继承Thread，重写run方法
2. 实现Runnable接口，重写run方法。
但是前两个都不能设置返回值
3. [实现Callable接口，可以有返回值](thread/CallTarget.java)
## synchronized
原理是：
当用synchronized锁住一段代码时，编译器会加入monitor，进入时是monitorenter，退出时是monitorexit。
所以当计数器不为0，则表示有线程在访问资源，则不允许其他线程访问。退出后，计数器-1，其他线程拿到锁。
monitor是每个对象都有的特性。（具体再细看）
这样会让synchronized变成同步操作。
synchronized在1.8后进行了优化，使用轻量级锁非都是重量级锁进行。
## volatile
为什么用这个修饰变量？
JVM有指令重排的优化。当程序是单线程时，指令重排对任务无影响。但是多线程时会出现一个线程拿到的实例并未初始化完成的情况。
所以需要用volatile修饰共享变量。保证对象在多线程情况下的安全。
## 锁
### 偏心锁
### 轻量级锁
### 自旋锁
### 重量级锁
### 共享锁
### 悲观锁
### 乐观锁